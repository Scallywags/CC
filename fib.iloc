				in "Argument? " => r_arg
				loadI 0 => r_0
				loadI 1 => r_1
				loadI #out => r_out
				
				push r_arg							//parameter
				push r_0							//return value (to be computed)
				push r_out							//return address

fib:			loadAI sp, 8 => r_n

				out "r_n: ", r_n
				out "sp: ", sp
				
				cmp_LE r_n, r_1 => r_cmp
				cbr r_cmp -> basecase, recursive

basecase:		out "BASE CASE r_n=", r_n
				storeAI r_1 => sp, 4
				load sp => pc
				jump -> pc
				
recursive:		loadI #fibNMinOne => r_fibNMinOne
				subI r_n, 2 => r_nMinTwo
				
				out "r_nMinTwo r_n=", r_n
				out "r_nMinTwo r_n-2=", r_nMinTwo
				
				push r_nMinTwo						//parameter
				push r_0							//return value
				push r_fibNMinOne					//return address
				jumpI -> fib
				
fibNMinOne:		loadI #sum => r_sum
				
				loadAI sp, 8 => r_n
				
				out "fibNMinOne r_n=", r_n
				
				subI r_n, 1 => r_nMinOne
				push r_nMinOne 						//parameter
				push r_0 							//return value
				push r_sum 							//return address
				jumpI -> fib

sum:			loadAI sp, 4 => r_nMinOneFib
				loadAI sp, 16 => r_nMinTwoFib
				
				add r_nMinOneFib, r_nMinTwoFib => r_fib
				
				addI sp, 24 => sp					//pop children records

				storeAI r_fib => sp, 4
				
				load sp => pc
				jump -> pc
				
out:			pop => r_retaddr
				pop => r_result
				pop => r_param
				out "Result: ", r_result